# FLP

- [FLP](#flp)
  - [1. 共识算法的定义](#1-共识算法的定义)
  - [2. FLP使用的背景](#2-flp使用的背景)
  - [3. FLP理论具体内容](#3-flp理论具体内容)
  - [4. 用FLP分析常见共识算法](#4-用flp分析常见共识算法)



原版论文：Impossibility of Distributed Consensus with One Faulty Process。FLP是这篇论文三个作者名字的首字母。

这篇论文最大的意义在于提供了一个**共识算法的不可能三角**。这样在设计算法，或者在依赖算法构建系统的时候就不会构建出一个不可能存在的系统。



## 1. 共识算法的定义

首先共识算法由**三个特性**定义：

- **Termination**:  算法会在有限步数完成，不能出现死锁无限循环的情况。这是一个liveness property。
- **Agreement**:  参与的进程最终必须选出一个且只有一个值。这里需要注意的点是这个值可以是任意值，比如输入集合是{1,2,3}， 输出可以是4。这是一个safety property。
- **Validity**: 选出的值必须是集合中的一个。也就是进程可以选出多个值，但是这些值必须在输入的集合中。这也是一个safety property。



## 2. FLP使用的背景

FLP有其使用的背景，这里的背景也就是在什么样假设情况下，FLP才有意义。

- 异步网络：网络中存在消息丢失，无上限的延迟，没有可靠的时钟，网络节点的计算速度也不一致。这基本上就是大家日常生活中的网络
- Crash Recovery Model：节点不存在欺骗行为，也就是系统中不存在Byzantine Failure。节点是按照程序逻辑运转的，结果也是有效的，但是结果返回时间是无上限的。而且节点也没有对任何数据持久化的保证。基本是也是大家日常生活中的机器表现的行为。



## 3. FLP理论具体内容

FLP理论告诉我们，**在异步网络 + Crash Recovery 的模型下，集群中只有有一个 faulty的进程，那么共识算法就不可能能够同时满足其应该具有的三个特性。**

这里的fault也就是论文题目中的Faulty，定义也是宽泛的：

- faulty：可能进程正常工作，网络中断，GC，或者进程挂掉。总之就是对端没有收到响应的保证，这也是上面说的Crash Recovery Model最常见的情况。



## 4. 用FLP分析常见共识算法

- Raft：Leader选举过程中可能会出现无限循环，虽然利用选举时间随机化可以减少这个可能性，但是概率学角度是可能出现的。所以只满足了Agreement 和 Validity
- Paxos：提案阶段可能会进入无限循环。所以只满足了Agreement 和 Validity。
- Redlock：这是redis号称使用的共识算法，这个算法比较特殊，因为Redis作者假定的集群中的时钟漂移是有上限的，在这个假定下是能够同时满足三个条件。但是如果在FLP的背景下来看的话，Redlock也是无法满足的,Redlock只满足了Termination和Validity。(因为时钟漂移可能存在一个节点投2次票，出现了2个值)。