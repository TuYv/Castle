- [1.CAP](#1cap)
  - [1.1 CAP的定义](#11-cap的定义)
  - [1.2 对Availability的分析](#12-对availability的分析)
  - [1.3 对Consistency的分析](#13-对consistency的分析)
    - [1.4 对Partition tolerance的分析](#14-对partition-tolerance的分析)
  - [1.5 对CAP引入对延迟的讨论](#15-对cap引入对延迟的讨论)
  - [1.6 系统设计真的要三选二吗](#16-系统设计真的要三选二吗)
  - [1.7 总结](#17-总结)
  - [1.8 使用CAP分析常用存储](#18-使用cap分析常用存储)
    - [1.1 Mysql](#11-mysql)
    - [1.2 无主复制的NoSQL](#12-无主复制的nosql)
    - [1.3 ZooKeeper](#13-zookeeper)

# 1.CAP
网上很多文章的观点都是觉得CAP理论就是单纯的三选二，其实这样的观点不能说错，但是也称不上对。本文尝试对CAP理论做出一些扩展，以及使用CAP对常见的数据库和NoSQL进行分析。

## 1.1 CAP的定义

- **Consistency**：实际上是可线性化，也就是Linearizability，Linearizability具体的定义可以看[这篇文章](https://github.com/LanceZL/Castle/blob/main/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8C%96.md)。
- **Availability**：non-failing node必须返回结果，对返回结果的正确性和延迟不做要求。
- **Partition tolerance** ：是指网络断开为两个以上的分区的时候, 节点之间会丢失消息。异步网络中，是一个不可避免的事情。



## 1.2 对Availability的分析

CAP的Availability和大家工作中遇到的可用性不太一样，这里要求的是所有没有发生故障(宕机，GC)的节点必须保证能够返回。比如Raft算法在发生分区的时候，只有大部分节点的集群才能向客户端服务，但是小部分节点的集群其实客户端也是可达的，但是小部分节点集群是无法保证返回的。

但是在工作中大家所说的可用性往往是**发生故障时(断电，过载，分区等)系统会不会停机，或者说会停机多长时间。一般用N个9表示。**

所以CAP理论中的可用性更加的极端，在工作中往往不会使用这种可用性来衡量。



## 1.3 对Consistency的分析

CAP中的Consistency虽然翻译叫 *一致性* ，但是实际上更应该说是 *可线性化*，也就是Linearizability。这是对一致性超高的保证，而且**最重要的是可线性化要求的是对单个对象的操作，真实世界里，可能一次查询就包含很多对象。**

更进一步，一致性不只有CAP和BASE理论里所说的可线性化和最终一致性，一致性的级别有很多，常用的就用：因果一致性，RYW一致性，FIFO一致性等等。所以这里的一致性的二元观点在实际情况中也是不适用的。



### 1.4 对Partition tolerance的分析

CAP中的Partition指的是网络分区，多个分区的机器无法互通。但是现实中真的是这样吗？

**现实中很难有一个手段去判定到底是对端故障，还是发生了分区，亦或是延迟。**

我们常常使用中心化的检查服务(etcd, zk)等来判断，但是这些服务都要求配置 一个延迟时间，可能只是网络堵塞了，这时就将对端判定为分区，从而牺牲A和C是非常不明智的。

所以CAP理论最大的缺点是没有引入对延迟的讨论。



## 1.5 对CAP引入对延迟的讨论

延迟和分区的表现是相似的，有时候对于A和C的选择都不是在发生分区的时候发生，而且在延迟的时候发生，**注意延迟意味着性能**：

- 取消延迟过大的操作——降低可用性
- 重试操作——可能带来一致性的损害

所以分区模型更应该用延迟模型来替代：

- 延迟代表分区，延迟越短，进去分区则会越频繁，可能在遇到分区的时候就要做出抉择。
- 放弃强一致来减少系统的高延迟（因为强一致放弃了Termination性质），在就近服务(data locality)上尤其有用。



## 1.6 系统设计真的要三选二吗

根据上面所说，分区往往是不容易判断的。现实中我们经常让监控服务使用一个延迟的临界值来当做分区。比如超过500ms就当做出现了分区。

如果真的发生了分区，也应该针对不同的业务场景做选择，比如对数据一致性要求高的请求选择C。也就是细粒度地选择A和C。

最重要的是在同一个数据中心内，分区是不那么常发生的，那么不应该在没有发生分区的时候在C和A中二选一。



## 1.7 总结

正确的做法应该是：

- 在没有出现分区的时候既保证A也要保证C
- 发生分区了：
  - 针对接口，重要性，数据特征选择A或者C
  - 在系统运行时，A和C的选择能够反复出现。
  - 考虑分区的判断(延迟)对性能的影响。
  - 一致性级别有很多种，可用性也一样。可以选择实现其他的可用性级别的同时还提供可用性。不是只能实现100%可用性和Linearizability。
- 分区恢复后，应该要恢复一致性和解决数据冲突带来的错误。



## 1.8 使用CAP分析常用存储

### 1.1 Mysql

对于主从复制功能的mysql，发生网络分区时：

- 客户端和主节点在一个分区，无法写入从节点，那么就不是A的
- 副本节点是异步的，那同步就是有延迟的，如果能从从节点读取，那么也不是C的。

所以**使用异步复制的读写分离的MySQl是既不A也不C的。**

### 1.2 无主复制的NoSQL

也叫Dynamo风格的NoSQL database。

发生分区的时候：

- 只有R=W=1的情况下才是满足CAP-A的。(这种RW设置太过极端)
- 基本上都设计成不可线性化。(但是可以通过手段实现可线性化)

但是Dynamo风格的NoSQL，却提供了因果一致性级别，而且还使用很多手段来提高可用性。

注意：Dynamo风格的系统大多都默认不提供可线性化的隔离级别的，比如Riak和Cassandra，而且推荐的R和W都不是1。**在这种情况下他们既不是A的也不是C的。**

Dynamo 风格的系统想实现可线性化需要：

- ABD算法实现读修复
- 全序广播来实现CAS

### 1.3 ZooKeeper

默认是不提供线性读取的，只提供前缀一致性读，发生网络分区时：

- 另一个分区没有之前客户端读到的数据，那么另一个分区就不可读。而且zk的写入是需要大多数节点同意的，所以小部分分区也是不可用的。
- 如果在发生分区后使用SYNC命令，那么是满足C的。

3.4 之后的只读模式也只是提供了读可用。**所以zk在没有使用sync的时候是既不A也不C的。**